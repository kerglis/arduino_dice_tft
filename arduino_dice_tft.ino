#include "MCUFRIEND_kbv.h"

MCUFRIEND_kbv tft;

#include "TouchScreen_kbv.h"         //my hacked version

const int XP=8,XM=A2,YP=A3,YM=9;    //240x320 ID=0x7575
const int TS_LEFT=888,TS_RT=161,TS_TOP=919,TS_BOT=111;

TouchScreen_kbv ts(XP, YP, XM, YM, 300);   //re-initialised after diagnose
TSPoint_kbv tp;                            //global point

#define LOWFLASH (defined(__AVR_ATmega328P__) && defined(MCUFRIEND_KBV_H_))

#define SCREEN_W    240

#define RED       0xF800
#define WHITE     0xFFFF
#define GREY      0x8410
#define BLACK     0x0000
//#define ORANGE    0xFA60
#define YELLOW    0xFFE0
//#define LIME      0x07FF
#define GREEN     0x07E0
//#define CYAN      0x07FF
//#define AQUA      0x04FF
#define BLUE      0x001F
//#define MAGENTA   0xF81F
//#define PINK      0xF8FF

#define DOT_COLOR   RED
#define DOT_RAD     6

#define DICE_COLOR  WHITE
#define DICE_SIZE   64
#define DICE_RADIUS 5

#define BAR_COUNT    11
#define BAR_TOTAL_W  ((BAR_W + BAR_GAP) * BAR_COUNT - BAR_GAP)

#define LEFT_MARGIN  (SCREEN_W - BAR_TOTAL_W) / 2
#define RIGHT_MARGIN (LEFT_MARGIN + BAR_TOTAL_W)

#define DICE_1_X    LEFT_MARGIN 
#define DICE_1_Y    110
#define DICE_2_X    RIGHT_MARGIN - DICE_SIZE
#define DICE_2_Y    DICE_1_Y
#define DICE_EXTRA_X (SCREEN_W - DICE_SIZE) / 2 
#define DICE_EXTRA_Y 20

#define BAR_COLOR   GREY
#define BAR_CHAR_COLOR WHITE
#define BAR_W       12
#define BAR_GAP     6
#define BAR_BASE    300

#define BITMAP_SIZE 48
#define BITMAP_DELTA (DICE_SIZE - BITMAP_SIZE)/2

const unsigned char shipBitmap [] PROGMEM = {
  // 'ship-48x48, 48x48px
  0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 
  0x00, 0x00, 0x00, 0x00, 0x5f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0x00, 0x00, 0x00, 0x01, 
  0xdf, 0xff, 0x80, 0x00, 0x00, 0x03, 0xcf, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xcf, 0xff, 0xc0, 0x00, 
  0x00, 0x0f, 0xcf, 0xff, 0xe0, 0x00, 0x00, 0x1f, 0xcf, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xcf, 0xff, 
  0xf0, 0x00, 0x00, 0x3f, 0xcf, 0xff, 0xf0, 0x00, 0x00, 0x3f, 0xcf, 0xff, 0xf8, 0x00, 0x00, 0x7f, 
  0xc7, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xc7, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xc7, 0xff, 0xfc, 0x00, 
  0x00, 0xff, 0xc7, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xc7, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xc7, 0xff, 
  0xfe, 0x00, 0x01, 0xff, 0xc7, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xc7, 0xff, 0xfe, 0x00, 0x03, 0xff, 
  0xc7, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xc7, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xc7, 0xfc, 0x0e, 0x00, 
  0x03, 0xff, 0xe7, 0xf0, 0x02, 0x00, 0x03, 0xff, 0xe7, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xe7, 0x80, 
  0x00, 0x00, 0x03, 0xff, 0xe6, 0x00, 0x1f, 0xf0, 0x03, 0xff, 0xe4, 0x0f, 0xff, 0xe0, 0x03, 0xf0, 
  0x20, 0xff, 0xff, 0xc0, 0x03, 0xc0, 0x0f, 0xff, 0xfe, 0x00, 0x03, 0x80, 0xff, 0xfc, 0x00, 0x00, 
  0x03, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x07, 0xfe, 0x00, 0x00, 0xfe, 0x03, 0xff, 
  0xfc, 0x00, 0x07, 0xe0, 0x7f, 0xff, 0xf8, 0x00, 0x0f, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x0c, 0x7f, 
  0xff, 0xff, 0xf8, 0x00, 0x03, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00
};

const unsigned char castleBitmap [] PROGMEM = {
  // 'castle-48x48, 48x48px
  0x00, 0x30, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x78, 0x00, 0x00, 0x1e, 0x00, 0x00, 0xf8, 0x00, 0x00, 
  0x1f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x3f, 0x80, 0x01, 0xfe, 
  0x00, 0x00, 0x7f, 0x80, 0x03, 0xfe, 0x00, 0x00, 0x7f, 0xc0, 0x03, 0xff, 0x00, 0x00, 0xff, 0xc0, 
  0x07, 0xff, 0x00, 0x00, 0xff, 0xe0, 0x07, 0xff, 0x80, 0x01, 0xff, 0xe0, 0x0f, 0xff, 0x80, 0x01, 
  0xff, 0xf0, 0x0f, 0xff, 0xc0, 0x03, 0xff, 0xf0, 0x1f, 0xff, 0xc0, 0x03, 0xff, 0xf8, 0x0f, 0xff, 
  0xc0, 0x03, 0xff, 0xf0, 0x07, 0xff, 0x00, 0x00, 0xff, 0xe0, 0x07, 0xff, 0x00, 0x00, 0xff, 0xe0, 
  0x07, 0xcf, 0x01, 0x80, 0xf3, 0xe0, 0x07, 0x87, 0x03, 0xc0, 0xe1, 0xe0, 0x07, 0x87, 0x03, 0xc0, 
  0xe1, 0xe0, 0x07, 0x87, 0x1f, 0xf8, 0xe1, 0xe0, 0x07, 0x87, 0x3f, 0xfc, 0xe1, 0xe0, 0x07, 0x87, 
  0x3e, 0x7c, 0xe1, 0xe0, 0x07, 0x87, 0x3c, 0x3c, 0xe1, 0xe0, 0x07, 0xff, 0x3c, 0x3c, 0xff, 0xe0, 
  0x07, 0xff, 0x3c, 0x3c, 0xff, 0xe0, 0x07, 0xff, 0x3c, 0x3c, 0xff, 0xe0, 0x07, 0xff, 0x3c, 0x3c, 
  0xff, 0xe0, 0x07, 0xff, 0xfc, 0x3f, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 
  0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xf0, 0x0f, 
  0xff, 0xf8, 0x1f, 0xff, 0xe0, 0x07, 0xff, 0xf8, 0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfc, 0x3f, 0xff, 
  0xc0, 0x03, 0xff, 0xfc, 0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfc, 0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfc, 
  0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfc, 0x7f, 0xff, 0xc0, 0x03, 0xff, 0xfe, 0x7f, 0xff, 0xc0, 0x03, 
  0xff, 0xfe, 0x7f, 0xff, 0xc0, 0x03, 0xff, 0xfe, 0x7f, 0xff, 0xc0, 0x03, 0xff, 0xfe, 0x7f, 0xff, 
  0xc0, 0x03, 0xff, 0xfe, 0x7f, 0xff, 0xc0, 0x03, 0xff, 0xfe, 0x3f, 0xff, 0xc0, 0x03, 0xff, 0xfc
};

int globalCount = 0;
long diceOne;
long diceTwo;
int stats[11] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int bar_left = DICE_1_X;

//-----------------------------------------

void setup() {
  Serial.begin(9600);
  uint16_t ID = tft.readID();

  tft.begin(ID);
  tft.fillScreen(BLACK);

  roll();
  
  printStats();
}

void loop() {
  bool justReleased = false;

  while (ISPRESSED() == true) {
    roll();
    justReleased = true;
  }

  if (justReleased) {
    long seed = analogRead(5);
    randomSeed(seed);

    int extraTimes = random(1, 5);

    for (int i = 0; i <= extraTimes; i++) {
      roll();
      delay(5);
    }

    storeStats();
    printStats();
  }
}

//-----------------------------------------

void roll() {
  rollTwoDices();
  rollExtraDice();
}

void readResistiveTouch(void) {
  tp = ts.getPoint();
  pinMode(YP, OUTPUT);      //restore shared pins
  pinMode(XM, OUTPUT);
  digitalWrite(YP, HIGH);  //because TFT control pins
  digitalWrite(XM, HIGH);
}

bool ISPRESSED(void) {
  // .kbv this was too sensitive !!
  // now touch has to be stable for 50ms
  int count = 0;
  bool state, oldstate;
  while (count < 10) {
    readResistiveTouch();
    state = tp.z > 200;     //ADJUST THIS VALUE TO SUIT YOUR SCREEN e.g. 20 ... 250
    if (state == oldstate) count++;
    else count = 0;
    oldstate = state;
    delay(5);
  }
  return oldstate;
}

void drawDice(int dice, int x, int y) {
  drawDiceBody(x, y);
  drawDots(dice, x, y);
}

void drawDiceBody(int x, int y) {
  tft.fillRoundRect(x, y, DICE_SIZE, DICE_SIZE, DICE_RADIUS, DICE_COLOR); 
}

void drawDots(int dice, int x, int y) {
  int y_top = y + DICE_SIZE / 4;
  int y_middle = y + DICE_SIZE / 2;
  int y_bottom = y + DICE_SIZE / 4 * 3;

  int x_left = x + DICE_SIZE / 4;
  int x_middle = x + DICE_SIZE / 2;
  int x_right = x + DICE_SIZE / 4 * 3;

  switch (dice)
  {
    case 1:
         tft.fillCircle(x_middle, y_middle, DOT_RAD, DOT_COLOR);
         break;
    case 2:
         tft.fillCircle(x_left, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_bottom, DOT_RAD, DOT_COLOR);
         break;
    case 3:
         tft.fillCircle(x_left, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_middle, y_middle, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_bottom, DOT_RAD, DOT_COLOR);
         break;
    case 4:
         tft.fillCircle(x_left, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_left, y_bottom, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_bottom, DOT_RAD, DOT_COLOR);
         break;
    case 5:
         tft.fillCircle(x_left, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_middle, y_middle, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_left, y_bottom, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_bottom, DOT_RAD, DOT_COLOR);
         break;
    case 6:
         tft.fillCircle(x_left, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_top, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_left, y_middle, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_middle, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_left, y_bottom, DOT_RAD, DOT_COLOR);
         tft.fillCircle(x_right, y_bottom, DOT_RAD, DOT_COLOR);
         break;
  }
}

void drawExtraDice(int dice, int x, int y) {
  drawDiceBody(x, y);
  drawExtraImages(dice, x, y);
}

void drawExtraImages(int dice, int x, int y) {
  long color;  

  switch (dice) {
    case 1:
         color = YELLOW;
         break;
    case 2:
         color = BLACK;
         break;
    case 3:
         color = BLUE;
         break;
    case 4:
         color = BLACK;
         break;
    case 5:
         color = GREEN;
         break;
    case 6:
         color = BLACK;
         break;
  }

  if (color == BLACK) {
    tft.drawBitmap(x + BITMAP_DELTA, y + BITMAP_DELTA, shipBitmap, BITMAP_SIZE, BITMAP_SIZE, color);
  } else
  {
    tft.drawBitmap(x + BITMAP_DELTA, y + BITMAP_DELTA, castleBitmap, BITMAP_SIZE, BITMAP_SIZE, color);
  }
}


void rollTwoDices() {
  long seed = analogRead(5);
  randomSeed(seed);

  diceOne = rollTheDice();
  diceTwo = rollTheDice();

  drawDice(diceOne, DICE_1_X, DICE_2_Y); // 30,  60);
  drawDice(diceTwo, DICE_2_X, DICE_2_Y); // 145, 60);
}

void rollExtraDice() {
  long seed = analogRead(5);
  randomSeed(seed);

  long diceExtra = rollTheDice();
  drawExtraDice(diceExtra, DICE_EXTRA_X, DICE_EXTRA_Y);
}

int rollTheDice() {
  int face = random(1, 100) % 3 + 1; // 1..3
  int direction = random(1, 100) % 2; // 0..1
  int dice = face + 3 * direction;

  if (dice < 1 ) {
    return 1;
  }

  if (dice > 6) {
    return 6;
  }

  return dice;
}

void storeStats() {
  int idx = diceOne + diceTwo - 2; // 0 based array starting with 2

  stats[idx] += 1;
  globalCount += 1;
}

void printStats() {
  int setColumn = 2;
  int num, idx;
  int maxVal = getMaxValue();

  for (int i = 0; i <= 10; i++) {
    printStatsBar(setColumn, stats[i], maxVal);
    setColumn += 1;
  }
}

void printStatsBar(int col, int val, int maxVal) {
  float proc;
  int x, y;

  if (maxVal == 0) {
    proc = 0;
  } else {
    proc = val * 100 / maxVal;
  }

  Serial.print(col);
  Serial.print(" >> ");
  Serial.println(proc);

  x = (col - 2) * (BAR_W + BAR_GAP) + bar_left;
  y = BAR_BASE - proc;

  // erase before
  tft.fillRect(x, BAR_BASE - 100, BAR_W, 100, BAR_COLOR);
  tft.fillRect(x, y, BAR_W, proc, BAR_CHAR_COLOR);

  drawBarNum(x, BAR_BASE + 5, col);
  drawStatsCount(x, BAR_BASE, col);
}

void drawBarNum(int x, int y, int num) {
  int delta = 0;

  if (num < 10) {
    delta = 3;
  }

  tft.setCursor(x + delta, y);
  tft.setTextColor(WHITE);
  tft.print(num);
}

void drawStatsCount(int x, int y, int col) {
  int delta = 1;

  if (stats[col - 2] < 10) {
    delta = 3;
  }

  tft.setCursor(x + delta, y - 10);
  tft.setTextColor(BLACK);
  tft.print(stats[col - 2]);
}

int getMaxValue() {
  int max = 0;

  for (int i = 0; i <= 10; i++){
    if (max < stats[i]) {
      max = stats[i];
    }
  }
  return max;
}
